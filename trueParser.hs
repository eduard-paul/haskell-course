module Calculator
    ( Expr
    , parseExpr
    , calcExpr
    )
    where
    
{- Выражение не очень удобно вычислять сразу при вводе, поэтому разумно 
сохранить его в новый тип данных, которое представить в виде синтаксического дерева.
Тип выражения параметризован типом чисел, которые в нём могут храниться.-}
data Expr a
    = Const a --константы
    | Binary BinOp <...> --операторы
    | Unary UnOp <...> --унарные операторы и функции
    
type BinOp :: a -> a -> a
type UnOp :: <...>
    
{- Выражение можно парсить. Проще всего сделать это методом рекурсивного спуска.
(https://ru.wikipedia.org/wiki/Метод_рекурсивного_спуска)
-}
parseExpr :: String -> Expr a
parseExpr = undefined
{- Разбор выражения можно сделать и любым другим методом, например, перегонкой через
обратную польскую запись. -}

{-Бонус 2: выражение также можно выводить.
instance Show a => Show (Expr a) where
    show (Const c) = show c
    show <...>
    
Но для этого придётся хранить функции в символьном виде:
data BinOp = Plus | <...>
-}
    
{- Выражение нужно уметь вычислять. -}
calcExpr :: Num a => Expr a -> a
calcExpr (Const a) = a --константа вычисляется в её значение
<...>

{- Бонус 1: вычислять выражение с переменными.
Для этого нужно добавить возможность хранить переменные в выражении.
Переменная однозначно определяется именем:
type Var = String
Для вычисления нужно передавать значения его переменных:
calcExpr :: Num a => [(Var, a)] -> Expr a -> a
Или же выводить выражение недовычисленным (бонус 1c):
calcExpr :: Num a => [(Var, a)] -> Expr a -> Expr a
-}